<div align="center">
<picture>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/GNU_Compiler_Collection_logo.svg/250px-GNU_Compiler_Collection_logo.svg.png" width="300" alt="GCC Compiler Logo">
</picture>

<h1 align="center">ğŸš€ Journey 02: Membungkus Logika dengan Bahasa C</h1>

<p align="center">
<b>The Bridge Between Human and Machine: Understanding Pointers & Memory Mapping</b>




Laboratorium: Debian 7 "Wheezy" | GCC Compiler
</p>
</div>

---

### 1. Pendahuluan: C adalah Assembly yang "Bisa Membaca"

Setelah berurusan dengan Register di Assembly, saya pindah ke bahasa C. Di sini, saya tidak lagi menulis nomor syscall secara manual, tapi saya masih bisa merasakan "detak jantung" hardware melalui **Pointer**.

### 2. Required (Alat Tempur)

* **Compiler:** `gcc` (GNU C Compiler).
* **Library:** `stdio.h` (Standard Input Output).
* **Insight:** C mengubah kode manusia menjadi file `.s` (Assembly) sebelum menjadi file eksekusi. Saya membuktikannya dengan perintah `gcc -S`.

---

### 3. Langkah-Langkah & Eksperimen Memori

#### ğŸ”µ Langkah 01: The Wrapper (Abstraksi Pertama)

**Tujuan:** Memahami bahwa `printf` adalah pembungkus (wrapper) dari `sys_write` yang saya pelajari sebelumnya.

* **Hasil:** Kode lebih ringkas, tapi tujuannya sama: mengirim data ke File Descriptor 1 (Layar).

#### ğŸŸ¡ Langkah 02: Memory Inspector (Melihat Koordinat RAM)

**Tujuan:** Mencari tahu di mana data disimpan secara fisik.

* **Key Concept:** Menggunakan operator `&` (Address-of) untuk melihat alamat heksadesimal.
* **Eksperimen:** Saya melihat bahwa variabel `char` dan `int` duduk berdampingan di RAM hanya selisih beberapa byte.

#### ğŸŸ¢ Checkpoint: The Memory Hacker (Pointer Manipulation)

**Tujuan:** Mengubah data tanpa menyentuh variabel aslinya (Pass by Reference).

* **Analogi:** Seperti memiliki "kunci cadangan" (Pointer) untuk masuk ke sebuah laci (Alamat Memori) dan mengganti isinya tanpa izin pemilik rumah.
* **Code Logic:**

```c
void hackMemori(int *target) {
    *target = *target + 9999; 
}

```

* **Real Result:** Saya berhasil meng-update nilai `saldo` melalui alamat memorinya. Ini adalah dasar bagaimana sistem operasi mengelola data secara efisien.

---

### 4. Kesimpulan & Impact

* **CRUD Level RAM:** Saya paham bahwa operasi "Update" di aplikasi apapun pada akhirnya adalah manipulasi alamat memori menggunakan Pointer.
* **Safety vs Power:** Bahasa C memberikan kekuatan penuh untuk "merusak" atau "memperbaiki" memori, sebuah tanggung jawab besar yang tidak ada di bahasa tingkat tinggi seperti Python.

**Next Stop:** Migrasi ke **C++** Bagaimana konsep "Class" dan "Object" membuat manajemen memori yang rumit ini menjadi lebih terorganisir?

<div align="center">
<p><b>Created with â¤ï¸ by Teungku | ğŸ¤– Gemini</b></p>
</div>